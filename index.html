<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Royale — Fortnite‑Inspired (GitHub Pages)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0b1020; color: #e8ecf1; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif; }
    #wrap { display: grid; grid-template-rows: auto 1fr auto; height: 100%; }
    header { padding: 10px 14px; display: flex; gap: 10px; align-items: center; background: linear-gradient(180deg,#0f1530,#0b1020); box-shadow: 0 2px 0 #0a0f1a; position: sticky; top: 0; z-index: 3; }
    header h1 { font-size: 16px; margin: 0; letter-spacing: .4px; }
    .btn { cursor: pointer; padding: 8px 12px; border-radius: 12px; outline: none; border: 0; background: #2a5fff; color: white; font-weight: 600; box-shadow: 0 4px 16px rgba(42,95,255,.35); }
    .btn.secondary { background: #1f2b4d; color: #a9b4d6; box-shadow: none; }
    main { display: grid; place-items: center; padding: 8px; }
    canvas { width: min(100vw, 1100px); height: min(70vh, 620px); image-rendering: pixelated; border-radius: 16px; background: #06101f; box-shadow: 0 12px 40px rgba(0,0,0,.45), inset 0 0 0 2px rgba(255,255,255,.05); }
    #hud { display: grid; grid-template-columns: 1fr auto; gap: 10px; width: min(100vw, 1100px); margin: 8px auto; align-items: center; padding: 0 8px 8px; }
    #hud .left { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .pill { background: #121a33; padding: 6px 10px; border-radius: 999px; font-size: 12px; color: #c7d2ff; }
    .bar { position: relative; width: 180px; height: 12px; background: #1a2447; border-radius: 8px; overflow: hidden; }
    .bar > span { position: absolute; left: 0; top: 0; bottom: 0; width: 50%; background: linear-gradient(90deg,#2a5fff,#4bd0ff); }
    .bar.shield > span { background: linear-gradient(90deg,#7a42ff,#b98bff); }

    /* Inventory */
    #inv { display: flex; gap: 8px; align-items: center; }
    .slot { width: 48px; height: 48px; background: #0c1226; border-radius: 10px; display: grid; place-items: center; box-shadow: inset 0 0 0 1px rgba(255,255,255,.06); position: relative; }
    .slot.active { outline: 2px solid #4bd0ff; }
    .slot small { position:absolute; bottom:4px; right:6px; font-size: 10px; color:#cfe7ff; }

    footer { padding: 10px 16px; color: #8fa0c8; font-size: 12px; opacity: .9; text-align: center; }

    /* overlays */
    .overlay { position: fixed; inset: 0; display: grid; place-items: center; background: linear-gradient(180deg, rgba(11,16,32,.86), rgba(11,16,32,.94)); backdrop-filter: blur(6px); z-index: 5; }
    .card { width: min(92vw, 780px); background: #0c1226; border-radius: 16px; padding: 18px; box-shadow: 0 12px 40px rgba(0,0,0,.5), inset 0 0 0 1px rgba(255,255,255,.06); }
    .card h2 { margin: 0 0 8px; font-size: 22px; }
    .card p { margin: 6px 0; color: #a9b4d6; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .kbd { background: #121a33; border: 1px solid #1c2750; padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color: #d8e0ff; }
    .actions { display: flex; justify-content: space-between; gap: 8px; margin-top: 12px; align-items:center; }
    .skin { width: 40px; height: 40px; border-radius: 10px; border: 2px solid rgba(255,255,255,.12); cursor: pointer; }
    .skin.selected { outline: 2px solid #4bd0ff; }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <h1>Mini Royale — Fortnite‑Inspired</h1>
      <button class="btn" id="playBtn">Play</button>
      <button class="btn secondary" id="resetBtn">Reset</button>
      <span class="pill" id="status">Ready</span>
      <span class="pill" id="botsLeft">Bots: 0</span>
      <span class="pill" id="stormTxt">Storm: calm</span>
      <span class="pill" id="matsTxt">Mats: 0</span>
    </header>
    <main>
      <canvas id="game" width="1100" height="620"></canvas>
      <div id="hud">
        <div class="left">
          <div class="pill">Move: <span class="kbd">WASD</span></div>
          <div class="pill">Aim: Mouse</div>
          <div class="pill">Shoot: <span class="kbd">Left Click</span></div>
          <div class="pill">Interact: <span class="kbd">E</span></div>
          <div class="pill">Build Wall: <span class="kbd">Q</span> · Rotate: <span class="kbd">R</span></div>
          <div class="pill">Slots: <span class="kbd">1‑5</span></div>
        </div>
        <div class="right" style="display:flex; gap:10px; align-items:center;">
          <div id="inv">
            <div class="slot" id="s0">AR<small>∞</small></div>
            <div class="slot" id="s1">SG<small>0</small></div>
            <div class="slot" id="s2">SMG<small>0</small></div>
            <div class="slot" id="s3">SNP<small>0</small></div>
            <div class="slot" id="s4">MED</div>
          </div>
          <div class="bar" title="Health"><span id="hpBar"></span></div>
          <div class="bar shield" title="Shield"><span id="shBar"></span></div>
        </div>
      </div>
    </main>
    <footer>
      Fan‑made, no Epic assets. Built for GitHub Pages.
    </footer>
  </div>

  <!-- START OVERLAY: Battle Bus + Skin Select -->
  <div class="overlay" id="startOverlay">
    <div class="card">
      <h2>Drop from the Bus</h2>
      <p>Pick a skin color, press <span class="kbd">Space</span> to drop, and glide to your landing. Loot, build, and survive the storm!</p>
      <div class="row" id="skins"></div>
      <div class="actions">
        <div class="row">
          <div class="pill">Drop: <span class="kbd">Space</span></div>
          <div class="pill">Glide: hold <span class="kbd">Space</span></div>
        </div>
        <button class="btn" id="startGame">Start Battle Bus</button>
      </div>
    </div>
  </div>

  <!-- GAME OVER OVERLAY -->
  <div class="overlay" id="gameOver" style="display:none">
    <div class="card">
      <h2 id="gameOverTitle">Game Over</h2>
      <p id="gameOverDesc">You placed #?.</p>
      <div class="actions">
        <div></div>
        <button class="btn" id="again">Play Again</button>
      </div>
    </div>
  </div>

  <script>
  // ====== Helpers ======
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const irand = (a,b)=>Math.floor(rand(a,b+1));
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const dist2 = (x1,y1,x2,y2)=>{ const dx=x2-x1, dy=y2-y1; return dx*dx+dy*dy; };
  const angleTo = (x1,y1,x2,y2)=>Math.atan2(y2-y1,x2-x1);

  // ====== Canvas & World ======
  const canvas = document.getElementById('game');
  const c = canvas.getContext('2d');
  const VW = canvas.width, VH = canvas.height; // viewport
  const WORLD = { w: 2200, h: 2200 };

  // Camera follows player
  const camera = { x: 0, y: 0 };
  const shake = { t:0, mag:0 };

  // ====== UI refs ======
  const statusEl = document.getElementById('status');
  const botsLeftEl = document.getElementById('botsLeft');
  const stormTxt = document.getElementById('stormTxt');
  const matsTxt = document.getElementById('matsTxt');
  const hpBar = document.getElementById('hpBar');
  const shBar = document.getElementById('shBar');
  const slots = [...document.querySelectorAll('.slot')];
  const startOverlay = document.getElementById('startOverlay');
  const gameOver = document.getElementById('gameOver');
  const gameOverTitle = document.getElementById('gameOverTitle');
  const gameOverDesc = document.getElementById('gameOverDesc');

  // ====== Input ======
  const keys = {};
  const mouse = {x:0,y:0,down:false};
  addEventListener('keydown',e=>{ keys[e.key.toLowerCase()]=true; if([' ','spacebar'].includes(e.key.toLowerCase())) e.preventDefault(); });
  addEventListener('keyup',e=>{ keys[e.key.toLowerCase()]=false; });
  canvas.addEventListener('mousemove',e=>{
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
    mouse.x = (e.clientX - rect.left) * scaleX; mouse.y = (e.clientY - rect.top) * scaleY;
  });
  canvas.addEventListener('mousedown',()=>{ mouse.down=true; });
  addEventListener('mouseup',()=>{ mouse.down=false; });

  // ====== Game State ======
  const state = {
    phase: 'menu', // 'bus' | 'drop' | 'play' | 'over'
    tick: 0,
    bots: [], bullets: [], loot: [], particles: [], walls: [], props: [],
    botCount: 20,
    storm: {
      center: {x: WORLD.w/2, y: WORLD.h/2},
      radius: 900,
      phases: [ {delay: 20*60, shrink: 0}, {delay: 30*60, shrink: 0.40}, {delay: 25*60, shrink: 0.50}, {delay: 20*60, shrink: 0.60} ],
      stage: 0, t: 0, dps: 0.4
    },
    bus: {x: -200, y: rand(400, WORLD.h-400), vx: 4.2, started:false, playerDropped:false},
    skins: ['#9dff7a','#7ad3ff','#ffd37a','#ff7aa8','#b98bff','#7affc2'],
    skin:'#9dff7a',
  };

  const player = {
    x: 0, y: 0, r: 14, speed: 2.6, vx:0, vy:0,
    hp: 100, shield: 50, maxHp:100, maxShield:100,
    mats: 0, alive:true, kills:0,
    slot: 0, // 0..4
    inventory: [
      {name:'AR', ammo: 90, stats:{spread:0.05, dmg:20, cd:10, speed:7.2, burst:1}},
      {name:'SG', ammo: 0,  stats:{spread:0.22, dmg:12, cd:36, speed:6.0, pellets:6}},
      {name:'SMG',ammo: 0,  stats:{spread:0.10, dmg:14, cd:6,  speed:7.6}},
      {name:'SNP',ammo: 0,  stats:{spread:0.01, dmg:60, cd:55, speed:9.0}},
      {name:'MED',uses: 0}
    ],
    fireCd:0,
    falling:false, gliding:false, altitude:0
  };

  // Skin chooser UI
  const skinsRow = document.getElementById('skins');
  state.skins.forEach((col,i)=>{
    const b = document.createElement('div'); b.className='skin'; b.style.background=col; if(i===0) b.classList.add('selected');
    b.onclick=()=>{ [...skinsRow.children].forEach(x=>x.classList.remove('selected')); b.classList.add('selected'); state.skin = col; };
    skinsRow.appendChild(b);
  });

  // ====== Spawns ======
  function spawnProps(){
    // Trees / rocks (mats sources) and chests
    for(let i=0;i<80;i++) state.props.push({ type:'tree', x:rand(100,WORLD.w-100), y:rand(100,WORLD.h-100), r:16, hp:60 });
    for(let i=0;i<35;i++) state.props.push({ type:'chest', x:rand(120,WORLD.w-120), y:rand(120,WORLD.h-120), r:14, opened:false });
  }

  function spawnBots(n){
    state.bots.length=0;
    for(let i=0;i<n;i++){
      const bx = rand(200,WORLD.w-200), by = rand(200,WORLD.h-200);
      state.bots.push({x:bx,y:by,r:12,hp:90,alive:true,cd:irand(10,40),type: ['AR','SMG','SG'][irand(0,2)]});
    }
  }

  function spawnLootCircle(cx,cy){
    const types = ['ammo','shield','med','smg','sg','snp','mats'];
    for(let i=0;i<5;i++) state.loot.push({x:cx+rand(-40,40), y:cy+rand(-40,40), type: types[irand(0,types.length-1)], taken:false});
  }

  function reset(full=false){
    state.tick=0; state.particles.length=0; state.bullets.length=0; state.walls.length=0; state.loot.length=0; state.props.length=0;
    state.storm.center = {x:WORLD.w/2 + rand(-200,200), y:WORLD.h/2 + rand(-200,200)};
    state.storm.radius = 900; state.storm.stage=0; state.storm.t=0; state.bus = {x: -200, y: rand(400, WORLD.h-400), vx: 4.2, started:false, playerDropped:false};
    Object.assign(player,{x:0,y:0,vx:0,vy:0,hp:100,shield:50,mats:0,alive:true,kills:0,slot:0,fireCd:0,falling:false,gliding:false,altitude:0});
    player.inventory = [
      {name:'AR', ammo: 90, stats:{spread:0.05, dmg:20, cd:10, speed:7.2, burst:1}},
      {name:'SG', ammo: 0,  stats:{spread:0.22, dmg:12, cd:36, speed:6.0, pellets:6}},
      {name:'SMG',ammo: 0,  stats:{spread:0.10, dmg:14, cd:6,  speed:7.6}},
      {name:'SNP',ammo: 0,  stats:{spread:0.01, dmg:60, cd:55, speed:9.0}},
      {name:'MED',uses: 0}
    ];
    updateInventoryUI();
    if(full){ spawnProps(); spawnBots(state.botCount); for(let i=0;i<16;i++){ spawnLootCircle(rand(200,WORLD.w-200), rand(200,WORLD.h-200)); } }
    updateHUD();
  }

  function updateInventoryUI(){
    const names = player.inventory.map(i=>i.name);
    slots.forEach((slot,idx)=>{
      slot.classList.toggle('active', idx===player.slot);
      const item = player.inventory[idx];
      if(item.name==='MED') slot.innerHTML = 'MED' + (item.uses?`<small>${item.uses}</small>`:'');
      else slot.innerHTML = `${item.name}<small>${item.ammo ?? 0}</small>`;
    });
  }

  // ====== Phases ======
  function startBattleBus(){
    state.phase='bus'; state.bus.started=true; startOverlay.style.display='none';
    // place player in bus
    player.x = state.bus.x; player.y = state.bus.y-40; player.altitude=450; player.falling=false; player.gliding=false;
  }

  function dropFromBus(){
    if(state.bus.playerDropped) return; state.bus.playerDropped=true; player.falling=true; statusEl.textContent='Dropping';
  }

  function startGame(){ state.phase='play'; statusEl.textContent='Play'; }

  // ====== Input bindings ======
  document.getElementById('playBtn').onclick = ()=>{ if(state.phase==='menu') startBattleBus(); };
  document.getElementById('resetBtn').onclick = ()=>{ gameOver.style.display='none'; startOverlay.style.display='grid'; state.phase='menu'; reset(true); };
  document.getElementById('startGame').onclick = ()=>{ startBattleBus(); };
  document.getElementById('again').onclick = ()=>{ state.phase='menu'; gameOver.style.display='none'; startOverlay.style.display='grid'; reset(true); };

  addEventListener('keydown', e=>{
    const k = e.key;
    if(state.phase==='bus' && (k===' '||k==='Spacebar')){ dropFromBus(); }
    if(k>='1'&&k<='5'){ player.slot = (+k)-1; updateInventoryUI(); }
    if(k.toLowerCase()==='q') tryBuild();
    if(k.toLowerCase()==='r') rotateGhost();
  });

  // ====== Building ======
  let ghost = {x:0,y:0,w:80,h:12,rot:0};
  function rotateGhost(){ ghost.rot = (ghost.rot+90)%360; }
  function tryBuild(){
    if(state.phase!=='play') return; if(player.mats<10) return;
    const wx = snapWorldX(camera.x + mouse.x), wy = snapWorldY(camera.y + mouse.y);
    const w = {x:wx, y:wy, w:ghost.w, h:ghost.h, rot:ghost.rot, hp:150};
    // must be near player
    if(Math.hypot(wx-player.x, wy-player.y) > 160) return;
    // prevent overlap with storm edge? allow.
    state.walls.push(w); player.mats -= 10; matsTxt.textContent = `Mats: ${player.mats|0}`;
  }
  function snapWorldX(x){ return Math.round(x/10)*10; }
  function snapWorldY(y){ return Math.round(y/10)*10; }

  // ====== Update / Loop ======
  let raf;
  function loop(){
    state.tick++;
    update();
    draw();
    raf = requestAnimationFrame(loop);
  }

  function update(){
    // Battle bus
    if(state.phase==='bus'){
      state.bus.x += state.bus.vx; player.x = state.bus.x; player.y = state.bus.y - 40; cameraTo(player.x, player.y);
      if(state.bus.x>WORLD.w+200 && !state.bus.playerDropped){ dropFromBus(); }
      if(state.bus.playerDropped){
        // fall and glide
        if(keys[' ']) player.gliding = true; else player.gliding = false;
        const fallSpeed = player.gliding ? 2.0 : 5.2;
        player.altitude = Math.max(0, player.altitude - fallSpeed);
        player.y += fallSpeed*0.7; cameraTo(player.x, player.y);
        if(player.altitude<=0){ startGame(); }
      }
      updateHUD(); return;
    }

    if(state.phase!=='play') return;

    // Camera follow
    cameraTo(player.x, player.y);

    // Movement
    const sp = player.speed;
    let ax = (keys['a']?-1:0) + (keys['d']?1:0);
    let ay = (keys['w']?-1:0) + (keys['s']?1:0);
    const mag = Math.hypot(ax,ay)||1; ax/=mag; ay/=mag;
    player.x = clamp(player.x + ax*sp, 16, WORLD.w-16);
    player.y = clamp(player.y + ay*sp, 16, WORLD.h-16);

    // Interact (E) — open chest / harvest tree
    if(keys['e']){
      for(const p of state.props){
        if(p.type==='chest' && !p.opened && dist2(player.x,player.y,p.x,p.y)<26*26){ p.opened=true; spawnLootCircle(p.x,p.y); pop(p.x,p.y,'loot'); }
        if(p.type==='tree' && p.hp>0 && dist2(player.x,player.y,p.x,p.y)<28*28){ p.hp -= 2; if(p.hp<=0){ player.mats += 40; matsTxt.textContent=`Mats: ${player.mats|0}`; pop(p.x,p.y,'mats'); } }
      }
    }

    // Weapons fire
    if(player.fireCd>0) player.fireCd--;
    const cur = player.inventory[player.slot];
    if(mouse.down && cur.name!=='MED' && player.fireCd<=0){
      if(cur.ammo>0 || cur.name==='AR'){
        const burst = cur.stats.burst||1;
        for(let i=0;i<burst;i++) shootFrom(player, cur);
        if(cur.name!=='AR') cur.ammo = Math.max(0, cur.ammo-1);
        player.fireCd = cur.stats.cd;
      }
    }
    // Use medkit in slot 5
    if(cur.name==='MED' && keys['e'] && cur.uses>0){ cur.uses--; player.hp = Math.min(player.maxHp, player.hp+40); }

    // Bots AI
    for(const b of state.bots){
      if(!b.alive) continue;
      const toPlayer = angleTo(b.x,b.y,player.x,player.y);
      // strafing movement
      b.x = clamp(b.x + Math.cos(toPlayer)*1.4 + Math.cos(state.tick*0.03+toPlayer)*0.7, 12, WORLD.w-12);
      b.y = clamp(b.y + Math.sin(toPlayer)*1.4 + Math.sin(state.tick*0.03+toPlayer)*0.7, 12, WORLD.h-12);
      // fire
      if(b.cd>0) b.cd--; else {
        const spread = {AR:0.06, SMG:0.10, SG:0.25}[b.type] || 0.06;
        const dmg    = {AR:18,  SMG:12,  SG:10}[b.type] || 18;
        const speed  = {AR:7.0, SMG:7.4, SG:6.0}[b.type] || 7.0;
        const pel    = b.type==='SG'?5:1;
        for(let i=0;i<pel;i++)
          state.bullets.push({x:b.x,y:b.y,vx:Math.cos(toPlayer+rand(-spread,spread))*speed,vy:Math.sin(toPlayer+rand(-spread,spread))*speed,life:80,from:'b',dmg});
        b.cd = irand(20,44);
        muzzle(b.x,b.y,toPlayer);
      }
    }

    // Bullets advance + collide
    for(const bullet of state.bullets){ bullet.x+=bullet.vx; bullet.y+=bullet.vy; bullet.life--; }

    // Bullet vs walls
    for(const bullet of state.bullets){
      if(bullet.life<=0) continue;
      for(const w of state.walls){ if(w.hp<=0) continue; if(hitWall(bullet,w)){ w.hp-=30; bullet.life=0; spark(bullet.x,bullet.y); if(w.hp<=0) pop(w.x,w.y,'break'); }
      }
    }

    // Bullet vs entities
    for(const bullet of state.bullets){
      if(bullet.life<=0) continue;
      if(bullet.from==='p'){
        for(const b of state.bots){ if(!b.alive) continue; if(dist2(bullet.x,bullet.y,b.x,b.y) < (b.r+2)*(b.r+2)){ dmgBot(b, bullet.dmg||20); bullet.life=0; spark(b.x,b.y); } }
      } else {
        if(player.alive && dist2(bullet.x,bullet.y,player.x,player.y) < (player.r+2)*(player.r+2)){
          damagePlayer(bullet.dmg||16); bullet.life=0; spark(player.x,player.y);
        }
      }
    }
    state.bullets = state.bullets.filter(b=>b.life>0 && b.x>-40 && b.y>-40 && b.x<WORLD.w+40 && b.y<WORLD.h+40);

    // Loot pickup
    for(const it of state.loot){ if(it.taken) continue; if(dist2(it.x,it.y,player.x,player.y)<22*22){ take(it); } }

    // Storm phases
    const st = state.storm;
    st.t++;
    const phase = st.phases[st.stage]||null;
    if(phase){
      stormTxt.textContent = `Storm: ${Math.max(0,Math.ceil((phase.delay - st.t)/60))}s`;
      if(st.t>=phase.delay){
        // shrink
        st.radius = Math.max(90, st.radius * (1-phase.shrink));
        st.center.x = clamp(st.center.x + rand(-120,120), 200, WORLD.w-200);
        st.center.y = clamp(st.center.y + rand(-120,120), 200, WORLD.h-200);
        st.stage++; st.t=0; st.dps += 0.25;
      }
    } else { stormTxt.textContent = 'Storm: final'; }

    // Storm damage
    const d2p = dist2(player.x,player.y,st.center.x,st.center.y);
    if(d2p>st.radius*st.radius) damagePlayer(st.dps/6);
    for(const b of state.bots){ if(!b.alive) continue; const d2b = dist2(b.x,b.y,st.center.x,st.center.y); if(d2b>st.radius*st.radius){ b.hp -= st.dps/6; if(b.hp<=0){ onBotDown(b); } } }

    // Remove dead bots
    for(const b of state.bots){ if(b.hp<=0 && b.alive){ onBotDown(b); } }

    // End conditions
    const aliveBots = state.bots.filter(b=>b.alive).length; botsLeftEl.textContent=`Bots: ${aliveBots}`;
    if(player.alive && aliveBots===0){ end(true); }
    if(!player.alive){ end(false); }

    updateHUD();
  }

  function cameraTo(x,y){ camera.x = clamp(x - VW/2, 0, WORLD.w - VW); camera.y = clamp(y - VH/2, 0, WORLD.h - VH); }

  // ====== Combat helpers ======
  function shootFrom(src, gun){
    const ang = angleTo(src.x,src.y, camera.x+mouse.x, camera.y+mouse.y) + rand(-gun.stats.spread, gun.stats.spread);
    const spd = gun.stats.speed;
    const dmg = gun.stats.dmg;
    const pellets = gun.stats.pellets||1;
    for(let i=0;i<pellets;i++) state.bullets.push({x:src.x,y:src.y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd, life:90, from:'p', dmg});
    muzzle(src.x,src.y,ang);
  }

  function damagePlayer(dmg){
    if(player.shield>0){ const absorb = Math.min(player.shield, dmg*1.2); player.shield -= absorb; dmg -= absorb*0.2; }
    player.hp -= dmg; if(player.hp<=0){ player.alive=false; }
  }

  function dmgBot(b, dmg){ b.hp -= dmg; if(b.hp<=0){ b.alive=false; onBotDown(b); player.kills++; } }
  function onBotDown(b){ b.alive=false; drop(b.x,b.y); pop(b.x,b.y,'down'); }

  function take(it){
    it.taken=true;
    if(it.type==='ammo'){ player.inventory[0].ammo += 30; }
    if(it.type==='shield'){ player.shield = clamp(player.shield+30,0,player.maxShield); }
    if(it.type==='med'){ player.inventory[4].uses = (player.inventory[4].uses||0)+1; }
    if(it.type==='smg'){ player.inventory[2].ammo += 40; }
    if(it.type==='sg'){ player.inventory[1].ammo += 12; }
    if(it.type==='snp'){ player.inventory[3].ammo += 5; }
    if(it.type==='mats'){ player.mats += 30; }
    updateInventoryUI(); matsTxt.textContent=`Mats: ${player.mats|0}`; pop(it.x,it.y,it.type);
  }

  function drop(x,y){
    const pool = ['ammo','shield','med','smg','sg','snp','mats'];
    for(let i=0;i<3;i++) state.loot.push({x:x+rand(-10,10),y:y+rand(-10,10),type: pool[irand(0,pool.length-1)], taken:false});
  }

  // ====== Collisions ======
  function hitWall(bul,w){
    // rotate bullet point into wall local space
    const rad = w.rot*Math.PI/180; const cos=Math.cos(-rad), sin=Math.sin(-rad);
    const lx = (bul.x - w.x)*cos - (bul.y - w.y)*sin;
    const ly = (bul.x - w.x)*sin + (bul.y - w.y)*cos;
    return Math.abs(lx) <= w.w/2 && Math.abs(ly) <= w.h/2;
  }

  // ====== FX ======
  function muzzle(x,y,a){ for(let i=0;i<8;i++) state.particles.push({x,y, vx:Math.cos(a+rand(-.5,.5))*rand(.5,2.5), vy:Math.sin(a+rand(-.5,.5))*rand(.5,2.5), r: rand(1,2), life: rand(6,14), col:'#ffd37a'}); }
  function spark(x,y){ for(let i=0;i<12;i++){ const a = rand(0,Math.PI*2); const s = rand(1,3); state.particles.push({x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, r: rand(1,2), life: rand(8,20), col:'#9ad1ff'}); } }
  function pop(x,y,type){ const col = type==='ammo'?'#9dff7a': type==='shield'?'#b98bff': type==='med'?'#ff7aa8': type==='mats'?'#ffd37a':'#cfe7ff'; for(let i=0;i<14;i++){ const a = rand(0,Math.PI*2); const s = rand(.6,2.6); state.particles.push({x,y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, r: rand(1,2.2), life: rand(8,20), col}); } }

  // ====== Draw ======
  function draw(){
    // clear viewport
    c.clearRect(0,0,VW,VH);

    // Parallax sky (pseudo 3D vibe)
    c.fillStyle = '#051022'; c.fillRect(0,0,VW,VH);
    c.fillStyle = '#071a33'; for(let i=0;i<8;i++){ c.fillRect(((i*300 - camera.x*0.2)% (VW+300))-150, 0, 180, VH); }

    // World grid
    c.save(); c.translate(-camera.x, -camera.y);
    c.strokeStyle = 'rgba(255,255,255,.05)'; c.lineWidth = 1;
    for(let x=0;x<=WORLD.w;x+=80){ c.beginPath(); c.moveTo(x,0); c.lineTo(x,WORLD.h); c.stroke(); }
    for(let y=0;y<=WORLD.h;y+=80){ c.beginPath(); c.moveTo(0,y); c.lineTo(WORLD.w,y); c.stroke(); }

    // Storm
    const st = state.storm; c.beginPath(); c.arc(st.center.x, st.center.y, st.radius, 0, Math.PI*2);
    c.strokeStyle = 'rgba(75,208,255,.7)'; c.lineWidth = 3; c.stroke(); c.fillStyle = 'rgba(75,208,255,.07)'; c.fill();

    // Props
    for(const p of state.props){
      if(p.type==='tree') { c.fillStyle='#1f7a5e'; c.beginPath(); c.arc(p.x,p.y,p.r,0,Math.PI*2); c.fill(); c.strokeStyle='rgba(0,0,0,.25)'; c.stroke(); }
      if(p.type==='chest' && !p.opened){ c.fillStyle='#b07c2a'; rectCenter(p.x,p.y,18,12); c.fillStyle='#d9b56a'; c.fillRect(p.x-8,p.y-2,16,4); }
    }

    // Loot
    for(const it of state.loot){ if(it.taken) continue; drawLoot(it); }

    // Walls
    for(const w of state.walls){ if(w.hp<=0) continue; drawWall(w); }

    // Bullets trails
    c.lineWidth = 2;
    for(const b of state.bullets){ c.strokeStyle = b.from==='p'? '#ffd37a':'#ff8b8b'; c.beginPath(); c.moveTo(b.x-b.vx*0.8, b.y-b.vy*0.8); c.lineTo(b.x, b.y); c.stroke(); }

    // Bots
    for(const b of state.bots){ if(!b.alive) continue; drawAgent(b,'#ff7aa8'); }

    // Player (or shadow while dropping)
    if(state.phase==='bus' && !state.bus.playerDropped){ drawBus(); }
    else if(state.phase==='bus' && state.bus.playerDropped && player.altitude>0){ drawAgent(player,state.skin,true, player.altitude); }
    else if(player.alive) drawAgent(player,state.skin,true, 0);

    // Particles
    for(const p of state.particles){ p.x+=p.vx; p.y+=p.vy; p.life--; if(p.life<0) continue; c.fillStyle = p.col; c.globalAlpha = Math.max(0,p.life/20); c.beginPath(); c.arc(p.x,p.y,p.r,0,Math.PI*2); c.fill(); c.globalAlpha=1; }
    state.particles = state.particles.filter(p=>p.life>0);

    c.restore();

    // Build ghost
    if(state.phase==='play'){
      const gx = snapWorldX(camera.x + mouse.x), gy = snapWorldY(camera.y + mouse.y);
      drawGhost(gx-camera.x, gy-camera.y);
    }
  }

  function drawGhost(sx,sy){
    c.save(); c.translate(sx,sy); c.rotate(ghost.rot*Math.PI/180); c.globalAlpha=0.4; c.fillStyle = player.mats>=10? '#7affc2':'#ff8b8b'; rectCenter(0,0,ghost.w,ghost.h); c.globalAlpha=1; c.restore();
  }

  function drawWall(w){ c.save(); c.translate(w.x,w.y); c.rotate(w.rot*Math.PI/180); c.fillStyle = '#284b7a'; rectCenter(0,0,w.w,w.h); c.strokeStyle='rgba(255,255,255,.2)'; c.strokeRect(-w.w/2,-w.h/2,w.w,w.h); c.restore(); }
  function drawLoot(it){ c.save(); if(it.type==='ammo'){ c.fillStyle = '#9dff7a'; rectCenter(it.x,it.y,14,10); } if(it.type==='shield'){ c.fillStyle = '#b98bff'; rectCenter(it.x,it.y,12,12); } if(it.type==='med'){ c.fillStyle = '#ff7aa8'; rectCenter(it.x,it.y,12,12); c.fillStyle='#fff'; c.fillRect(it.x-2,it.y-6,4,12); c.fillRect(it.x-6,it.y-2,12,4); } if(it.type==='smg'){ c.fillStyle='#7ad3ff'; rectCenter(it.x,it.y,14,10); } if(it.type==='sg'){ c.fillStyle='#ffd37a'; rectCenter(it.x,it.y,14,10); } if(it.type==='snp'){ c.fillStyle='#cfe7ff'; rectCenter(it.x,it.y,14,10); } if(it.type==='mats'){ c.fillStyle='#b07c2a'; rectCenter(it.x,it.y,14,10); } c.restore(); }
  function drawAgent(a, color, isPlayer=false, altitude=0){
    // shadow
    c.fillStyle = 'rgba(0,0,0,.35)'; c.beginPath(); c.ellipse(a.x, a.y+8, a.r*1.1, a.r*0.6, 0, 0, Math.PI*2); c.fill();
    // body
    c.fillStyle = color; c.beginPath(); c.arc(a.x,a.y,a.r,0,Math.PI*2); c.fill();
    // gun toward mouse/player
    let ang = 0; if(isPlayer){ ang = angleTo(a.x,a.y, camera.x+mouse.x, camera.y+mouse.y); } else { ang = angleTo(a.x,a.y,player.x,player.y); }
    const gx = a.x + Math.cos(ang)*a.r; const gy = a.y + Math.sin(ang)*a.r;
    c.strokeStyle = '#e8ecf1'; c.lineWidth = 3; c.beginPath(); c.moveTo(a.x,a.y); c.lineTo(gx,gy); c.stroke();
    // outline
    c.strokeStyle = 'rgba(255,255,255,.35)'; c.lineWidth = 1.5; c.beginPath(); c.arc(a.x,a.y,a.r,0,Math.PI*2); c.stroke();
    // glider if altitude
    if(altitude>0){ c.strokeStyle='#cfe7ff'; c.beginPath(); c.arc(a.x, a.y-20, 26, Math.PI*1.1, Math.PI*1.9); c.stroke(); }
  }
  function drawBus(){ c.save(); c.fillStyle='#2a5fff'; rectCenter(state.bus.x, state.bus.y, 120, 40); c.fillStyle='#4bd0ff'; rectCenter(state.bus.x+30, state.bus.y-24, 24, 20); c.restore(); }
  function rectCenter(x,y,w,h){ c.fillRect(x-w/2,y-h/2,w,h); }

  // ====== HUD ======
  function updateHUD(){
    hpBar.style.width = (player.hp/player.maxHp*100)+"%";
    shBar.style.width = (player.shield/player.maxShield*100)+"%";
    matsTxt.textContent = `Mats: ${player.mats|0}`;
    updateInventoryUI();
  }

  // ====== Boot ======
  reset(true);
  statusEl.textContent = 'Ready';
  startOverlay.style.display='grid';
  loop();
  </script>
</body>
</html>
